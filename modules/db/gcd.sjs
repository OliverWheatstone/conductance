var { propertyPairs } = require('sjs:object');
var { each, map, Stream, transform, join, buffer, unpack, slice, reduce, filter, indexed, toArray, at } = require('sjs:sequence');
var { isArrayLike } = require('sjs:array');
var { instantiate, traverse, isSimpleType, IdToKey } = require('./schema');

//----------------------------------------------------------------------
// Google Cloud Datastore 

// Serialized key: kind.name/kind.name/...
// kind and name must not contain slashes or dots.
// kinds and names matching the regexp __.*__ are reserved by GCD
// name must not start with '#' (unless generated by the db - see GCD docs).

// Example:

// key:      'Company.Oni Labs/Person.Alexander Fritze'
// parent:   'Company.Oni Labs'
// id:       'Alexander Fritze'
// kind:     'Person'

function keyToGCDKey(path) {
  return path.split('/') ..
    map(function(pelem) {
      var [kind, id_or_name] = pelem.split(':');
      if (!id_or_name)
        return { kind: kind };
      else if (id_or_name.charAt(0) == '#')
        return { kind: kind, id: id_or_name.substr(1) }
      else
        return { kind: kind, name: id_or_name }
    });
}

function GCDKeyToKey(path) {
  return path .. 
    transform({kind, name, id} -> name ? "#{kind}:#{name}" : "#{kind}:##{id}") ..
    join('/');
}

function GCDKeyToId(path) {
  var last = path[path.length-1];
  return last.id ? "##{last.id}" : last.name;
}

function GCDKeyToParent(path) {
  return GCDKeyToKey(path .. slice(0,-1));
}


function GCDValueToJSValue(gcd_value, descriptor) {
  var base_val;
  switch (descriptor.__type) {
  case 'date':
    if (gcd_value.timestampMicrosecondsValue === undefined)
      base_val = null;
    else
      base_val = new Date(parseInt(gcd_value.timestampMicrosecondsValue.substr(0,gcd_value.timestampMicrosecondsValue.length-3)));
    break;
  case 'bool':
    if (gcd_value.integerValue === undefined)
      base_val = null;
    else
      base_val = Boolean(Number(gcd_value.integerValue));
    break;
  case 'integer':
    if (gcd_value.integerValue === undefined)
      base_val = null;
    else
      base_val = Number(gcd_value.integerValue);
    break;
  case 'float':
    if (gcd_value.doubleValue === undefined)
      base_val = null;
    else
      base_val = Number(gcd_value.doubleValue);
    break;
  case 'string':
  case 'text':
    if (gcd_value.stringValue === undefined)
      base_val = null;
    else
      base_val = gcd_value.stringValue;
    break;
  case 'ref':
    if (gcd_value.keyValue === undefined)
      base_val = null;
    else
      base_val = GCDKeyToKey(gcd_value.keyValue.pathElement);
    break;
  default:
    throw new Error("Schema error: Unknown type #{descriptor.__type}");
  }
  if (descriptor.fromRepository)
    base_val = descriptor.fromRepository(base_val);
  return base_val;
}

function JSValueToGCDValue(js_val, descriptor) {
  var value = {};

  if (descriptor.toRepository)
    js_val = descriptor.toRepository(js_val);

  if (js_val === null) {
    if (descriptor.__allowNull)
      return value;
    else
      throw "Invalid 'null' value on a #{descriptor.__type} property without '__allowNull'";
  }
  
  switch (descriptor.__type) {
  case 'date':
    value.timestampMicrosecondsValue = js_val.getTime()+'000';
    break;
  case 'bool':
    value.integerValue = Boolean(js_val);
    break;
  case 'integer':
    value.integerValue = Number(js_val);
    break;
  case 'float':
    value.doubleValue = Number(js_val);
    break;
  case 'text':
    value.indexed = false;
    // fall through to string
  case 'string':
    value.stringValue = String(js_val);
    break;
  case 'ref':
    value.keyValue = {pathElement:keyToGCDKey(js_val)};
    break;
  default:
    throw "Unknown type #{descriptor.__type}";
  }
  return value;
}

function JSEntityToGCDEntity(js_entity, schema) {
  var gcd_entity = {key: {}, property:[]};
  var parent, key, id, kind;

  // helper to map a single js value to a gcd value, based on given schema descriptor
  function extractProperty(js_val, descriptor) {
    if (js_val === undefined) {
      if (descriptor.__defval !== undefined) {
        if (typeof descriptor.__defval == 'function')
          js_val = descriptor.__defval();
        else
          js_val = descriptor.__defval;
      }
//XXX      else if (descriptor.__required)
//        throw "Validation error: Missing value for property #{name}";
      else 
        return;
    }

    if (descriptor.toRepository)
      js_val = descriptor.toRepository(js_val);

    switch (descriptor.__type) {
      // first some 'special' types:
    case 'key':
      key = js_val;
      if (descriptor.toRepository)
        key = descriptor.toRepository(key);
      break;
    case 'id':
      id = js_val;
      if (descriptor.toRepository)
        id = descriptor.toRepository(id);
      break;
    case 'parent':
      parent = js_val;
      if (descriptor.toRepository)
        parent = descriptor.toRepository(parent);
      break;
    default:
      // a normal serialized value
      return JSValueToGCDValue(js_val, descriptor);
    }
  }

  function parseSchemaObj(schemaobj, path, array_path) {
    try {
      propertyPairs(schemaobj) .. each {
        |[name, descriptor]|
        if (name == '__parent') {
          if (path || array_path) throw "Unexpected '__parent'";
          parent = descriptor;
        }
        else if (name == '__kind') {
          if (path || array_path) throw "Unexpected '__kind'";
          kind = descriptor;
        }
        else if (isArrayLike(descriptor)) {
          if (descriptor.length != 1) throw "#{name}: Polymorphic arrays not supported";
          if (array_path) throw "#{name}: Nested arrays not supported";
          if (typeof descriptor[0] !== 'object') throw "#{name}: Invalid array descriptor: Object expected";
          
          if (descriptor[0].__type) {
            // descriptor describes a property -> fetch all values
            var base = path ? path .. reduce(js_entity, (v,p) -> v === undefined ? undefined : v[p]) : js_entity;
            // XXX validation on array? like e.g. non-empty arrays?
            if (base && base[name] && base[name].length) {
              gcd_entity.property.push({
                name: path ? path.join('.')+'.'+name : name,
                multi: true,
                value: base[name] .. transform(x -> extractProperty(x, descriptor[0])) /* XXX .. filter(x->x!==undefined) */ .. toArray
              });                
            }
            
          }
          else // descriptor is a sub object
            parseSchemaObj(descriptor[0], path ? path.concat(name) : [name], []);
        }
        else if (typeof descriptor === 'object') { 
          if (descriptor.__type) {
            // descriptor describes a property on js_entity
            if (array_path) {
              // property nested in array
              // iterate over all array elements and accumulate all values found at array_path
              // relative to the array.

              // XXX currently each array element needs to be
              // reachable otherwise an exception will be thrown. Also
              // if a value is 'undefined' subsequent array values get out of
              // sync with their indexes on retrieval
              var base = path .. reduce(js_entity, (v,p) -> v === undefined ? undefined : v[p]);
              // XXX validation on array itself (rather than elements?)
              if (base && base.length) { 
                try { 
                  gcd_entity.property.push({
                    name: path.concat(array_path).join('.') + '.' + name,
                    multi: true,
                    value: base .. 
                      transform(arr_base -> reduce(array_path, arr_base, (arr_base,prop) -> arr_base[prop])[name] ..
                                            extractProperty(descriptor)) ..
                      toArray
                  });
                }
                catch (e) { 
                  throw "Invalid format of array data (#{e})";
                }
              }
            }
            else {
              // single valued property:
              var base = path ? path .. reduce(js_entity, (v,p) -> v === undefined ? undefined : v[p]) : js_entity;
              try {
                var value = extractProperty(base ? base[name] : undefined, descriptor);
              }
              catch (e) {
                if (typeof e === 'string')
                  e += " (#{name})";
                throw e;
              }
              if (value !== undefined) {
                gcd_entity.property.push({
                  name: path ? path.join('.') + '.' + name : name,
                  value: [value]
                });
              }
            }
          }
          else {
            // descriptor is a sub object
            parseSchemaObj(descriptor, path ? path.concat(name) : [name], array_path);
          }
        }
        else 
          throw "Invalid descriptor type '#{typeof descriptor}' for #{name}";
      }
    }
    catch (e) {
      if (typeof e === 'string') {
        // XXX add path/array_path to error
        var err = "Schema error: #{e}.";
        if (path || array_path) {
          err += " (";
          if (path)
            err += "path = '#{path}'";
          if (array_path)
            err += " array_path = '#{array_path}'";
          err += ")";
        }
        throw new Error(err);
      }
      else
        throw e;
    }
  }

  parseSchemaObj(schema);

  if (!key) {
    if (parent)
      key = parent + '/';
    else 
      key = '';
    if (!kind) throw new Error("Schema missing '__kind' definition.");
    key += kind;
    if (id)
      key += ":#{id}";
  }
  else if (id) {
    // check that key and id are consistent:
    if (key.lastIndexOf(id) !== key.lastIndexOf(':')+1)
      throw new Error("Id #{id} inconsistent with key #{key}");
  }

  gcd_entity.key.pathElement = keyToGCDKey(key);

  return gcd_entity;
}

function GCDEntityToJSEntity(gcd_entity, schema) {
  var kind = gcd_entity.key.pathElement[gcd_entity.key.pathElement.length-1].kind;

  var js_entity = instantiate(schema);

  // go through properties array of GCD entity:
  gcd_entity.property .. each {
    |{name, value}|
    // find schema descriptor:
    var descriptor=schema, path=[], array_path;
    name.split('.') .. each {
      |n|
      descriptor = descriptor[n];
      if (!descriptor) break; 
      if (isArrayLike(descriptor)) {
        if (array_path) throw new Error("Invalid schema: nested arrays");
        path = path.concat(n);
        array_path = [];
        descriptor = descriptor[0];
      }
      else {
        if (array_path) {
          array_path = array_path.concat(n);
        }
        else {
          path = path.concat(n);
        }
      }
    }

    if (!descriptor) continue;

    // make sure path exists in js_entity:
    var target = path .. slice(0,-1) .. 
      reduce(js_entity, (target, p) -> target[p] ? target[p] : (target[p] = {}));

    if (!array_path) {
      // a single value
      target[path .. at(-1)] = GCDValueToJSValue(value[0], descriptor);
    }
    else {
      if (!target[path .. at(-1)])
        target = target[path .. at(-1)] = [];
      else
        target = target[path .. at(-1)];
      value .. indexed .. each { 
        |[i,v]|
        if (!array_path.length)
          target[i] = GCDValueToJSValue(v, descriptor);
        else {
          var base = target[i];
          if (!base) base = target[i] = {};
          base = array_path .. slice(0, -1) .. 
            reduce(base, (base, p) -> base[p] ? base[p] : (base[p] = {}));

          base[array_path .. at(-1)] = GCDValueToJSValue(v, descriptor);
        }
      }
    }
  }

  // now go through schema and pick up special properties (such as
  // __key), check if required properties are there, and fill in default properties
  propertyPairs(schema) .. each {
    |[name, descriptor]|
    if (js_entity[name]) continue; // already there
    var base_val;
    switch (descriptor.__type) {
    case 'id':
      base_val = GCDKeyToId(gcd_entity.key.pathElement);
      break;
    case 'key':
      base_val = GCDKeyToKey(gcd_entity.key.pathElement);
      break;
    case 'parent':
      base_val = GCDKeyToParent(gcd_entity.key.pathElement);
      break;
    default:
//XXX      if (descriptor.__required)
//        throw new Error("Schema validation error: Missing value for property #{name}");
    }
    if (base_val !== undefined) {
      if (descriptor.fromRepository)
        base_val = descriptor.fromRepository(base_val);
      js_entity[name] = base_val;
    }
  }

  return js_entity;
}

function GoogleCloudDatastore(attribs) {
  var context = require('./gcd/backend/google-cloud-datastore').Context(attribs);
  // returns a 'Repository' object
  var rv = {
    put: function(entity, schema) {
      entity = JSEntityToGCDEntity(entity, schema);
      //console.log(require('sjs:debug').inspect(entity, false, 10));
      var mutation = {};

      // check if the entity has a full key path:
      var last = entity.key.pathElement[entity.key.pathElement.length-1];
      var has_path = (last.id || last.name);

      if (has_path) {
//        console.log("upserting #{require('sjs:debug').inspect(entity, false, 10)}");
        mutation.upsert = [entity];
      }
      else
        mutation.insertAutoId = [entity];

      var result = context.blindWrite({mutation: mutation});

      return has_path ? 
        entity.key.pathElement .. GCDKeyToKey :
        result.mutationResult.insertAutoIdKey[0].pathElement .. GCDKeyToKey;
    },

    get: function(key, schema) {
      var result = context.lookup({
        key: [ { pathElement: keyToGCDKey(key) } ]
      });
      if (!result.found) return null;
      return result.found[0].entity .. GCDEntityToJSEntity(schema);
    },

    remove: function(key) {
      context.blindWrite({mutation: { 'delete': [{pathElement: keyToGCDKey(key)}]}});
    },

    query_old: function(query) {

      // untangle args:

      var filters = [];
      var kinds = [];
      var orders = [];
      var schema;

      propertyPairs(query) .. each {
        |[name, value]|
        switch (name) {
        case 'kind':
          kinds = (isArrayLike(value) ? value : [value]) ..
            map(kind -> {name:kind});
          break;
        case 'hasAncestor':
          filters.push({
            propertyFilter: {
              property: {name: '__key__'},
              operator: 'HAS_ANCESTOR',
              value: { keyValue: { pathElement:keyToGCDKey(value) }}
            }
          }); 
          break;
        case 'order':
          orders = (isArrayLike(value) ? value : [value]) .. 
            map(order -> order.charAt(0) == '-' ?
                { property: {name:order.substr(1)}, direction:'DESCENDING' } :
                { property: {name:order}, direction:'ASCENDING' });
          break;
        case 'schema':
          schema = value;
          break;
        default:
          throw new Error("Unknown keyword #{name} in query");
        }
      }

      var batchStream = Stream(function(r) {
        // construct query request:
        var request = {query: {}};
        
        if (filters.length == 1) {
          request.query.filter = filters[0];
        }
        else if (filters.length > 1) {
          request.query.filter = {
            compositeFilter: {
              operator: 'AND',
              filter: filters
            }
          };
        }
        
        if (kinds.length) {
          request.query.kind = kinds;
        }

        if (orders.length) {
          request.query.order = orders;
        }

        if (!schema) {
          request.query.projection = [ { property:{name:'__key__'}}];
        }

//        console.log(require('sjs:debug').inspect(request, false, 20));

        while (1) {
          var results = context.runQuery(request);
          if (!results.batch || !results.batch.entityResult) break;
          r(results.batch.entityResult);
          // XXX not sure this logic is correct; 
          // see https://groups.google.com/d/msg/gcd-discuss/iNs6M1jA2Vw/kn7VVgxQeHkJ
          //console.log(results.batch.moreResults);
          if (results.batch.moreResults != 'NOT_FINISHED' ||!results.batch.endCursor) break;
          request.query.startCursor = results.batch.endCursor; 
        }
      });

      // buffer(1) ensures that we already perform the next GCD
      // request while processing results; this is to compensate for
      // GCD's high latency
      return batchStream .. 
        buffer(1) .. 
        unpack ..
        transform({entity} -> schema ? 
                  GCDEntityToJSEntity(entity, schema) :
                  GCDKeyToKey(entity.key.pathElement));
    },

    query: function(query, schema, idsOnly) {
      if (typeof schema !== 'object') throw new Error('Invalid schema argument'); 
      var filters = [];
      var kind = schema.__kind;
      var orders = [];
      var id, key;

      traverse(query, schema) {
        |{parent, property_name:prop, type, schema, schema_path:path}|
        if (parent[prop] === undefined) continue;
        if (type === 'id') {
          id = parent[prop];
        }
        else if (type === 'key') {
          key = parent[prop];
        }
        else if (isSimpleType(type)) {
          // XXX support other types than just equality filters
          filters.push({
            propertyFilter: {
              property: {name: path.replace('.[]','')},
              operator: 'EQUAL',
              value: JSValueToGCDValue(parent[prop],schema)
            }
          });
        }
      }

      if (key !== undefined) {
        filters.push({
          propertyFilter: {
            property: {name: '__key__'},
            operator: 'EQUAL',
            value: { keyValue: { pathElement: keyToGCDKey(key) } }
          }
        });
      }
      else if (id !== undefined) {
        filters.push({
          propertyFilter: {
            property: {name: '__key__'},
            operator: 'EQUAL',
            value: { keyValue: { pathElement: keyToGCDKey(IdToKey(id, schema)) } }
          }
        });
      }
      else if (schema.__parent) {
        filters.push({
          propertyFilter: {
            property: {name: '__key__'},
            operator: 'HAS_ANCESTOR',
            value: { keyValue: { pathElement:keyToGCDKey(schema.__parent) } }
          }
        });
      }

      var batchStream = Stream(function(r) {
        // construct query request:
        var request = {query: {}};
        
        if (filters.length == 1) {
          request.query.filter = filters[0];
        }
        else if (filters.length > 1) {
          request.query.filter = {
            compositeFilter: {
              operator: 'AND',
              filter: filters
            }
          };
        }
        
        if (kind) {
          request.query.kind = [{name:kind}];
        }

        if (orders.length) {
          request.query.order = orders;
        }

        if (idsOnly) {
          request.query.projection = [ { property:{name:'__key__'}}];
        }

//        console.log(require('sjs:debug').inspect(request, false, 20));

        while (1) {
          var results = context.runQuery(request);
          if (!results.batch || !results.batch.entityResult) break;
          r(results.batch.entityResult);
          // XXX not sure this logic is correct; 
          // see https://groups.google.com/d/msg/gcd-discuss/iNs6M1jA2Vw/kn7VVgxQeHkJ
          //console.log(results.batch.moreResults);
          if (results.batch.moreResults != 'NOT_FINISHED' ||!results.batch.endCursor) break;
          request.query.startCursor = results.batch.endCursor; 
        }
      });

      // buffer(1) ensures that we already perform the next GCD
      // request while processing results; this is to compensate for
      // GCD's high latency
      return batchStream .. 
        buffer(1) .. 
        unpack ..
        transform({entity} -> idsOnly ? 
                  GCDKeyToKey(entity.key.pathElement) :
                  GCDEntityToJSEntity(entity, schema)
                 );
    }
  };

  return rv;
}
exports.GoogleCloudDatastore = GoogleCloudDatastore;
