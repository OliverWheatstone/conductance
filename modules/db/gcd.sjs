var { propertyPairs } = require('sjs:object');
var { each, map, Stream, transform, join, buffer, unpack, slice, reduce, filter, indexed, toArray, at } = require('sjs:sequence');
var { isArrayLike } = require('sjs:array');
var { instantiate, isSimpleType, IdToKey, cotraverse } = require('./schema');
var { Context } = require('./gcd/backend');
var { ChangeBuffer } = require('./helpers');

//----------------------------------------------------------------------
// Google Cloud Datastore 

// Serialized key: kind.name/kind.name/...
// kind and name must not contain slashes or dots.
// kinds and names matching the regexp __.*__ are reserved by GCD
// name must not start with '#' (unless generated by the db - see GCD docs).

// Example:

// key:      'Company.Oni Labs/Person.Alexander Fritze'
// parent:   'Company.Oni Labs'
// id:       'Alexander Fritze'
// kind:     'Person'

function keyToGCDKey(path) {
  return path.split('/') ..
    map(function(pelem) {
      var [kind, id_or_name] = pelem.split(':');
      if (!id_or_name)
        return { kind: kind };
      else if (id_or_name.charAt(0) == '#')
        return { kind: kind, id: id_or_name.substr(1) }
      else
        return { kind: kind, name: id_or_name }
    });
}

function GCDKeyToKey(path) {
  return path .. 
    transform({kind, name, id} -> name ? "#{kind}:#{name}" : "#{kind}:##{id}") ..
    join('/');
}

function GCDKeyToId(path) {
  var last = path[path.length-1];
  return last.id ? "##{last.id}" : last.name;
}

function GCDKeyToKind(path) {
  var last = path[path.length-1];
  return last.kind;
}

function GCDKeyToParent(path) {
  return GCDKeyToKey(path .. slice(0,-1));
}


function GCDValueToJSValue(gcd_value, descriptor) {
  var base_val;
  switch (descriptor.__type) {
  case 'date':
    if (gcd_value.timestampMicrosecondsValue === undefined)
      base_val = null;
    else
      base_val = new Date(parseInt(gcd_value.timestampMicrosecondsValue.substr(0,gcd_value.timestampMicrosecondsValue.length-3)));
    break;
  case 'bool':
    if (gcd_value.integerValue === undefined)
      base_val = null;
    else
      base_val = Boolean(Number(gcd_value.integerValue));
    break;
  case 'integer':
    if (gcd_value.integerValue === undefined)
      base_val = null;
    else
      base_val = Number(gcd_value.integerValue);
    break;
  case 'float':
    if (gcd_value.doubleValue === undefined)
      base_val = null;
    else
      base_val = Number(gcd_value.doubleValue);
    break;
  case 'string':
  case 'text':
    if (gcd_value.stringValue === undefined)
      base_val = null;
    else
      base_val = gcd_value.stringValue;
    break;
  case 'ref':
    if (gcd_value.keyValue === undefined)
      base_val = null;
    else
      base_val = GCDKeyToKey(gcd_value.keyValue.pathElement);
    break;
  default:
    throw new Error("Schema error: Unknown type #{descriptor.__type}");
  }
  if (descriptor.fromRepository)
    base_val = descriptor.fromRepository(base_val);
  return base_val;
}

function JSValueToGCDValue(js_val, descriptor) {
  var value = {};

/*  if (descriptor.toRepository)
    js_val = descriptor.toRepository(js_val);
*/
  if (js_val === null) {
    if (descriptor.__allowNull)
      return value;
    else
      throw "Invalid 'null' value on a #{descriptor.__type} property without '__allowNull'";
  }
  
  switch (descriptor.__type) {
  case 'date':
    value.timestampMicrosecondsValue = js_val.getTime()+'000';
    break;
  case 'bool':
    value.integerValue = Boolean(js_val);
    break;
  case 'integer':
    value.integerValue = Number(js_val);
    break;
  case 'float':
    value.doubleValue = Number(js_val);
    break;
  case 'text':
    value.indexed = false;
    // fall through to string
  case 'string':
    value.stringValue = String(js_val);
    break;
  case 'ref':
    value.keyValue = {pathElement:keyToGCDKey(js_val)};
    break;
  default:
    throw "Unknown type #{descriptor.__type}";
  }
  return value;
}

function JSEntityToGCDEntity(js_entity, schemas) {
  var schema = schemas[js_entity.schema];
  if (!schema) throw new Error("Unknown schema #{js_entity.schema}");
  var key = js_entity.id;
  var gcd_entity = { property:[] };

  js_entity.data .. cotraverse(schema) {
    |node, descriptor|
    //console.log("iterating #{node.path} #{node.value}");
    if (descriptor.type === 'object') {
      // feed through parent context (or create new one at the root)
      node.state = node.parent_state || {};
      // if we're in an array, every field of structured data must
      // exist (see also comment below):
      if (node.state.arr_ctx && node.value === undefined)
        throw new Error("Google Cloud Datastore: Undefined values in arrays not supported (#{node.path})");
    }
    else if (descriptor.type === 'key') {
      if (key && node.value !== key) 
        throw new Error("Google Cloud Datastore: Inconsistent key values in data ('#{key}' != '#{node.value}')");
      key = node.value;
    }
    else if (descriptor.type === 'array') {
      if (node.parent_state.arr_ctx)
        throw new Error("Google Cloud Datastore: Nested arrays not supported (#{node.path})");
      node.state = Object.create(node.parent_state);
      node.state.arr_ctx = {};
    }
    else if (node.parent_state.arr_ctx) {
      // we're in an array

      // We store structed array data in separate, parallel
      // multi-valued properties.  For this scheme to work, every
      // field of a structured array value must have a value (possibly
      // 'Null'), otherwise the correspondance between array fields
      // will get out of sync. 
      if (node.value === undefined) 
        throw new Error("Google Cloud Datastore: Undefined values in arrays not supported (#{node.path})");

      if (!node.parent_state.arr_ctx[descriptor.path]) {
        gcd_entity.property.push({
          name: descriptor.path.replace(".[]", ""),
          multi: true,
          value: (node.parent_state.arr_ctx[descriptor.path] = [])
        });
      }
      node.parent_state.arr_ctx[descriptor.path].push(JSValueToGCDValue(node.value, descriptor.value));
    }
    else if (node.value !== undefined) {
      // a single-valued property:
      gcd_entity.property.push({
        name: node.path,
        value: [JSValueToGCDValue(node.value, descriptor.value)]
      });
    }
  }

  if (!key) {
    key = schema.__parent ? schema.__parent + '/' : '';
    key += js_entity.schema;
  }

  gcd_entity.key = { pathElement: keyToGCDKey(key) };

  return gcd_entity;
}


function GCDEntityToJSEntity(gcd_entity, schemas) {
  var kind = GCDKeyToKind(gcd_entity.key.pathElement);
  var schema = schemas[kind];
  if (!schema) throw new Error("Google Cloud Datastore: Unknown schema #{kind}");

  var js_data = instantiate(schema);

  // go through properties array of GCD entity:
  (gcd_entity.property || []) .. each {
    |{name, value}|
    // find schema descriptor:
    var descriptor=schema, path=[], array_path;
    name.split('.') .. each {
      |n|
      descriptor = descriptor[n];
      if (!descriptor) break; 
      if (isArrayLike(descriptor)) {
        if (array_path) throw new Error("Invalid schema: nested arrays");
        path = path.concat(n);
        array_path = [];
        descriptor = descriptor[0];
      }
      else {
        if (array_path) {
          array_path = array_path.concat(n);
        }
        else {
          path = path.concat(n);
        }
      }
    }

    if (!descriptor) continue;

    // make sure path exists in js_data:
    var target = path .. slice(0,-1) .. 
      reduce(js_data, (target, p) -> target[p] ? target[p] : (target[p] = {}));

    if (!array_path) {
      // a single value
      target[path .. at(-1)] = GCDValueToJSValue(value[0], descriptor);
    }
    else {
      if (!target[path .. at(-1)])
        target = target[path .. at(-1)] = [];
      else
        target = target[path .. at(-1)];
      value .. indexed .. each { 
        |[i,v]|
        if (!array_path.length)
          target[i] = GCDValueToJSValue(v, descriptor);
        else {
          var base = target[i];
          if (!base) base = target[i] = {};
          base = array_path .. slice(0, -1) .. 
            reduce(base, (base, p) -> base[p] ? base[p] : (base[p] = {}));

          base[array_path .. at(-1)] = GCDValueToJSValue(v, descriptor);
        }
      }
    }
  }

  // now go through schema and pick up special properties (such as
  // __key), check if required properties are there, and fill in default properties
  propertyPairs(schema) .. each {
    |[name, descriptor]|
    if (js_data[name]) continue; // already there
    var base_val;
    switch (descriptor.__type) {
    case 'id':
      base_val = GCDKeyToId(gcd_entity.key.pathElement);
      break;
    case 'key':
      base_val = GCDKeyToKey(gcd_entity.key.pathElement);
      break;
    case 'parent':
      base_val = GCDKeyToParent(gcd_entity.key.pathElement);
      break;
    default:
//XXX      if (descriptor.__required)
//        throw new Error("Schema validation error: Missing value for property #{name}");
    }
    if (base_val !== undefined) {
      js_data[name] = base_val;
    }
  }

  return { id: GCDKeyToKey(gcd_entity.key.pathElement), schema: kind,  data: js_data};
}

/**
   @function GoogleCloudDatastore
   @return {GCD} Google Cloud Datastore instance
   @param {Object} [attribs]
   @attrib {Object} [schemas]
   @attrib {Object} [context] Object with settings as described at [./gcd/backend::Context] (Note: this should not be a `Context` object itself, but a hash of settings that will be passed to to [./gcd/backend::Context]!)
 */

function GoogleCloudDatastore(attribs) {
  var CHANGE_BUFFER_SIZE = 100; // XXX should this be configurable?
  var change_buffer = ChangeBuffer(CHANGE_BUFFER_SIZE);
  var context = Context(attribs.context);
  var schemas = attribs.schemas;
  // returns a 'Datastore' object
  var rv = {
    /**
       @function GCD.write
       @param {datastore::Entity} [entity] Entity to create/update/delete
       @summary Create/update/delete an entity in the datastore
       @desc
          If `entity` is of the form
          
              {  id:     IDENTIFIER_STRING,
                 schema: SCHEMA_NAME,
                 data:   SIMPLE_JS_OBJ
              }

          then the item identified by `id` will be updated with `data` as described by the
          given `schema`. If the item does not exist yet, a new item will be created.

          If `entity` is of the form
 
              {  schema: SCHEMA_NAME,
                 data:   SIMPLE_JS_OBJ
              }

          then a new item with the given `data` as described by `schema` will be created.
          
          If `entity` is of the form

              {  id: IDENTIFIER_STRING,
                 data: undefined|null
              }
               
          then the given item will be deleted from the datastore.
     */
    write: function(entity) {
      if (entity.data === undefined || entity.data === null) {
        // DELETE
        context.blindWrite({mutation: { 'delete': [{pathElement: keyToGCDKey(entity.id)}]}});
        return entity.id;
      }
      // else UPSERT
      entity = JSEntityToGCDEntity(entity, schemas);
      //console.log(require('sjs:debug').inspect(entity, false, 10));
      var mutation = {};

      // check if the entity has a full key path:
      var last = entity.key.pathElement[entity.key.pathElement.length-1];
      var has_path = (last.id || last.name);

      if (has_path) {
//        console.log("upserting #{require('sjs:debug').inspect(entity, false, 10)}");
        mutation.upsert = [entity];
      }
      else
        mutation.insertAutoId = [entity];

      var result = context.blindWrite({mutation: mutation});

      var id = has_path ? 
        entity.key.pathElement .. GCDKeyToKey :
        result.mutationResult.insertAutoIdKey[0].pathElement .. GCDKeyToKey;

      change_buffer.addChange(id);

      return id;
    },

    /**
       @function GCD.read
     */
    read: function(entity) {
      var result = context.lookup({
        key: [ { pathElement: keyToGCDKey(entity.id) } ]
      });
      if (!result.found) return null;
      return result.found[0].entity .. GCDEntityToJSEntity(schemas);
    },

    /**
       @function GCD.query
     */
    query: function(entity, idsOnly) {
      var schema = schemas[entity.schema];
      if (!schema) throw new Error("Unknown schema #{entity.schema}");

      // XXX all of our queries are currently kind-queries
      var kind = entity.schema;
      
      var filters = [];
      var orders = [];
      var key = entity.id;

      if (entity.data) {
        cotraverse(entity.data, schema) {
          |node, descriptor|
          if (node.value === undefined) continue;
          if (descriptor.type === 'key') {
            if (key && node.value !== key) 
              throw new Error("Google Cloud Datastore: Inconsistent key values in data ('#{key}' != '#{node.value}')");
            key = node.value;
          }
          else if (isSimpleType(descriptor.type)) {
            // XXX support other types than just equality filters
            filters.push({
              propertyFilter: {
                property: {name: descriptor.path.replace('.[]','')},
                operator: 'EQUAL',
                value: JSValueToGCDValue(node.value, descriptor.value)
              }
            });
          }
        }
      }

      if (key !== undefined) {
        filters.push({
          propertyFilter: {
            property: {name: '__key__'},
            operator: 'EQUAL',
            value: { keyValue: { pathElement: keyToGCDKey(key) } }
          }
        });
      }
      else if (schema.__parent) {
        filters.push({
          propertyFilter: {
            property: {name: '__key__'},
            operator: 'HAS_ANCESTOR',
            value: { keyValue: { pathElement:keyToGCDKey(schema.__parent) } }
          }
        });
      }

      var batchStream = Stream(function(r) {
        // construct query request:
        var request = {query: {}};
        
        if (filters.length == 1) {
          request.query.filter = filters[0];
        }
        else if (filters.length > 1) {
          request.query.filter = {
            compositeFilter: {
              operator: 'AND',
              filter: filters
            }
          };
        }
        
        if (kind) {
          request.query.kind = [{name:kind}];
        }

        if (orders.length) {
          request.query.order = orders;
        }

        if (idsOnly) {
          request.query.projection = [ { property:{name:'__key__'}}];
        }

//        console.log(require('sjs:debug').inspect(request, false, 20));

        while (1) {
          var results = context.runQuery(request);
          if (!results.batch || !results.batch.entityResult) break;
          r(results.batch.entityResult);
          // XXX not sure this logic is correct; 
          // see https://groups.google.com/d/msg/gcd-discuss/iNs6M1jA2Vw/kn7VVgxQeHkJ
          //console.log(results.batch.moreResults);
          if (results.batch.moreResults != 'NOT_FINISHED' ||!results.batch.endCursor) break;
          request.query.startCursor = results.batch.endCursor; 
        }
      });

      // buffer(1) ensures that we already perform the next GCD
      // request while processing results; this is to compensate for
      // GCD's high latency
      return batchStream .. 
        buffer(1) .. 
        unpack ..
        transform({entity} -> idsOnly ? 
                  GCDKeyToKey(entity.key.pathElement) :
                  GCDEntityToJSEntity(entity, schemas)
                 );
    },

    watch: function(f) {
      var start_revision = change_buffer.revision, current_revision;
      while (true) {
        current_revision = change_buffer.emitter.wait();
        while (current_revision !== start_revision) {
          f(change_buffer.getChanges(start_revision));
          start_revision = current_revision;
          current_revision = change_buffer.revision;
        }
      }
    }


  };

  return rv;
}
exports.GoogleCloudDatastore = GoogleCloudDatastore;
